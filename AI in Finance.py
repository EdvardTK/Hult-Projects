# -*- coding: utf-8 -*-
"""Individual Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FcqmJOZ89baoCYgO4lQJ6cZkLssfv55d
"""

import numpy as np
import itertools
import pandas as pd
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from scipy.stats import skew, kurtosis
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
import yfinance as yf
import plotly.graph_objs as go

from google.colab import drive
drive.mount('/content/drive')

crypto = pd.read_csv("/content/drive/MyDrive/crypto-markets.csv")
crypto

# Display the first few rows of the DataFrame to understand its structure
print("First few rows of the DataFrame:")
print(crypto.head())

# Generate descriptive statistics for all numeric columns
print("\nDescriptive Statistics:")
print(crypto.describe())

# Check for missing values
print("\nMissing Values:")
print(crypto.isnull().sum())

# Display information about the DataFrame
print("\nDataFrame Info:")
print(crypto.info())

# Convert date column to datetime
crypto['date'] = pd.to_datetime(crypto['date'])

# Get the top 10 symbols by average market cap
top_symbols = crypto.groupby('name')['market'].mean().nlargest(10).index

# Filter the dataset to include only the top 10 symbols
crypto_top = crypto[crypto['name'].isin(top_symbols)]

# Histogram of Closing Prices by Top 10 Symbols
fig1 = px.histogram(crypto_top, x='close', nbins=50, title='Distribution of Closing Prices by Top 10 Symbols', facet_col='name', facet_col_wrap=3)
fig1.update_layout(xaxis_title='Closing Price', yaxis_title='Frequency')
fig1.show()

# 2. Time Series Plot of Market Cap
fig2 = px.line(crypto, x='date', y='market', title='Market Cap Over Time', color='name')
fig2.update_layout(xaxis_title='Date', yaxis_title='Market Cap')
fig2.show()

# 3. Scatter Plot of Volume vs. Market Cap
fig3 = px.scatter(crypto, x='volume', y='market', title='Volume vs. Market Cap', color='name', log_x=True, log_y=True)
fig3.update_layout(xaxis_title='Volume', yaxis_title='Market Cap')
fig3.show()

# Convert date column to datetime
crypto['date'] = pd.to_datetime(crypto['date'])

# Filter data for the specified date range
crypto_filtered = crypto[(crypto['date'] >= '2016-01-01') & (crypto['date'] <= '2018-11-30')].copy()

# Calculate the total return for each cryptocurrency in this period
crypto_filtered['return'] = crypto_filtered.groupby('name')['close'].pct_change()

# Summing returns to find top 10 cryptos (not the best way but for simplicity we use this method)
crypto_returns = crypto_filtered.groupby('name')['return'].sum().reset_index()

# Select the top 10 cryptocurrencies with the highest returns
top_10_cryptos = crypto_returns.nlargest(10, 'return')['name']

# Filter the dataset to include only the top 10 cryptocurrencies
crypto_top_10 = crypto_filtered[crypto_filtered['name'].isin(top_10_cryptos)].copy()

# Calculate equal weights for the top 10 cryptocurrencies
weights = {crypto: 1/10 for crypto in top_10_cryptos}

# Calculate weighted returns
crypto_top_10['weighted_return'] = crypto_top_10.apply(lambda row: row['return'] * weights[row['name']], axis=1)

# Aggregating portfolio returns
portfolio_returns = crypto_top_10.groupby('date')['weighted_return'].sum().reset_index()

# Visualization 1: Weights of the top 10 cryptocurrencies
weights_df = pd.DataFrame(list(weights.items()), columns=['name', 'weight'])
fig1 = px.pie(weights_df, values='weight', names='name', title='Portfolio Weights of Top 10 Cryptocurrencies')
fig1.show()

# Visualization 2: Portfolio returns over time
fig2 = px.line(portfolio_returns, x='date', y='weighted_return', title='Portfolio Returns Over Time')
fig2.update_layout(xaxis_title='Date', yaxis_title='Weighted Return')
fig2.show()

# Visualization 3: Impact of each asset on the portfolio returns
crypto_top_10['month'] = crypto_top_10['date'].dt.to_period('M').dt.to_timestamp()
monthly_returns = crypto_top_10.groupby(['month', 'name'])['weighted_return'].sum().unstack().fillna(0)
fig3 = px.area(monthly_returns, title='Impact of Each Asset on Portfolio Returns')
fig3.update_layout(xaxis_title='Date', yaxis_title='Weighted Return')
fig3.show()

# Convert date column to datetime
crypto['date'] = pd.to_datetime(crypto['date'])

# Calculate returns separately
returns = crypto.groupby('name')['close'].apply(lambda x: x.pct_change()).reset_index()
returns.rename(columns={'close': 'return'}, inplace=True)

# Merge returns back to the original dataframe using the same index type
crypto['index'] = crypto.index
returns['index'] = returns.index
crypto = crypto.merge(returns[['index', 'return']], on='index', how='left')
crypto.drop(columns=['index'], inplace=True)

# Remove the first row of each group where return is NaN
crypto.dropna(subset=['return'], inplace=True)

# Calculate Sharpe Ratio for each cryptocurrency
risk_free_rate = 0.01  # Assume a risk-free rate of 1%

def calculate_sharpe_ratio(group):
    mean_return = group['return'].mean()
    std_return = group['return'].std()
    sharpe_ratio = (mean_return - risk_free_rate) / std_return
    return pd.Series({'sharpe_ratio': sharpe_ratio, 'mean_return': mean_return, 'std_return': std_return})

sharpe_ratios = crypto.groupby('name').apply(calculate_sharpe_ratio).reset_index()

# Select the top 10 cryptocurrencies with the highest Sharpe Ratios
top_10_cryptos = sharpe_ratios.nlargest(10, 'sharpe_ratio')['name']

# Filter the dataset to include only the top 10 cryptocurrencies
crypto_top_10 = crypto[crypto['name'].isin(top_10_cryptos)].copy()

# Calculate equal weights for the top 10 cryptocurrencies
weights = {crypto: 1/len(top_10_cryptos) for crypto in top_10_cryptos}

# Calculate weighted returns
crypto_top_10['weighted_return'] = crypto_top_10.apply(lambda row: row['return'] * weights[row['name']], axis=1)

# Aggregating portfolio returns
portfolio_returns = crypto_top_10.groupby('date')['weighted_return'].sum().reset_index()

# Basic mathematical operations using NumPy
mean_return = np.mean(portfolio_returns['weighted_return'])
std_return = np.std(portfolio_returns['weighted_return'])
cumulative_return = np.cumprod(1 + portfolio_returns['weighted_return'].values)[-1] - 1

print(f"Mean Return: {mean_return}")
print(f"Standard Deviation of Return: {std_return}")
print(f"Cumulative Return: {cumulative_return}")

# Calculate Sharpe Ratio
sharpe_ratio = (mean_return - risk_free_rate) / std_return
print(f"Sharpe Ratio: {sharpe_ratio}")

# Calculate Sortino Ratio
downside_std_return = np.std(portfolio_returns[portfolio_returns['weighted_return'] < 0]['weighted_return'])
sortino_ratio = (mean_return - risk_free_rate) / downside_std_return
print(f"Sortino Ratio: {sortino_ratio}")

# Analyze distribution of returns
skewness = skew(portfolio_returns['weighted_return'])
kurt = kurtosis(portfolio_returns['weighted_return'])
print(f"Skewness: {skewness}")
print(f"Kurtosis: {kurt}")

# Calculate Value at Risk (VaR) and Conditional Value at Risk (CVaR)
VaR_95 = np.percentile(portfolio_returns['weighted_return'], 5)
CVaR_95 = portfolio_returns[portfolio_returns['weighted_return'] <= VaR_95]['weighted_return'].mean()
print(f"Value at Risk (VaR) 95%: {VaR_95}")
print(f"Conditional Value at Risk (CVaR) 95%: {CVaR_95}")

# Visualization 1: Weights of the top 10 cryptocurrencies
weights_df = pd.DataFrame(list(weights.items()), columns=['name', 'weight'])
fig1 = px.pie(weights_df, values='weight', names='name', title='Portfolio Weights of Top 10 Cryptocurrencies')
fig1.show()

# Visualization 2: Portfolio returns over time
fig2 = px.line(portfolio_returns, x='date', y='weighted_return', title='Portfolio Returns Over Time')
fig2.update_layout(xaxis_title='Date', yaxis_title='Weighted Return')
fig2.show()

# Visualization 3: Impact of each asset on the portfolio returns
crypto_top_10['month'] = crypto_top_10['date'].dt.to_period('M').dt.to_timestamp()
monthly_returns = crypto_top_10.groupby(['month', 'name'])['weighted_return'].sum().unstack().fillna(0)
fig3 = px.area(monthly_returns, title='Impact of Each Asset on Portfolio Returns')
fig3.update_layout(xaxis_title='Date', yaxis_title='Weighted Return')
fig3.show()

# Machine Learning: Random Forest for pattern recognition
# Prepare the dataset for modeling
crypto_top_10['day_of_week'] = crypto_top_10['date'].dt.dayofweek
features = ['day_of_week', 'volume', 'market']
X = crypto_top_10[features].fillna(0)
y = crypto_top_10['return'].fillna(0)

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and train the Random Forest model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# Predict and evaluate the model
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse}")

# Feature importance
feature_importance = pd.DataFrame({'feature': features, 'importance': rf_model.feature_importances_})
fig4 = px.bar(feature_importance, x='feature', y='importance', title='Feature Importance in Random Forest Model')
fig4.show()

# 1. Correlation Analysis
returns_matrix = crypto_top_10.pivot(index='date', columns='name', values='return')
correlation_matrix = returns_matrix.corr()
fig, ax = plt.subplots(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', ax=ax)
ax.set_title('Correlation Matrix of Top 10 Cryptocurrencies')
plt.show()

# 2. Beta Analysis
# Assuming the overall market return is the average return of all cryptocurrencies
market_returns = crypto.groupby('date')['return'].mean().reset_index()
crypto_top_10 = crypto_top_10.merge(market_returns, on='date', suffixes=('', '_market'))
crypto_top_10['beta'] = crypto_top_10.groupby('name').apply(lambda x: np.cov(x['return'], x['return_market'])[0, 1] / np.var(x['return_market'])).reset_index(drop=True)
beta_df = crypto_top_10[['name', 'beta']].drop_duplicates()
fig2 = px.bar(beta_df, x='name', y='beta', title='Beta of Top 10 Cryptocurrencies')
fig2.show()